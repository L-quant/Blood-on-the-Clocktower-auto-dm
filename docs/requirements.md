# 血染钟楼 auto-dm - 需求说明文档

## 1. 项目概述
### 1.1 项目背景
本项目旨在开发辅助血染钟楼（一款线下多人社交推理桌游）的自动化系统，系统需要可以彻底完全代替人类说书人进行游戏流程推进、规则判定、信息分发和复盘总结等功能。
### 1.2 核心场景
- **线下聚会**：玩家面对面围坐。
- **双端交互**：
    - **玩家端（移动手机网页端）**：玩家各自持有，用于接收私人身份、夜晚行动、投票操作和各种消息通知。
    - **后端（服务器端）**：处理游戏逻辑、Agent调度、房间和状态管理、数据持久化、与玩家端通信。
- **免登录**：追求极致的开局速度，无需注册账号，创建房间的玩家就是房主，其他玩家输入房主提供的房间号即可加入小镇，也就是加入游戏房间。

---

## 2. 角色与用户画像
| 角色 | 权限与功能 |
| :--- | :--- |
| **房主 (Host)** | 创建房间、选择板子（剧本）、控制游戏开始、处理突发争议。（但房主也是一个玩家，所以在房主点击开始游戏后房主要自动降级为玩家身份，房主并没有全知的上帝视角） |
| **玩家 (Player)** | 加入房间、选择座位、接收身份信息、执行夜晚技能、白天讨论、提名与投票。 |
| **主 Agent (Main Agent)** | **流程控制者**。负责维护全局状态机，唤醒玩家，调用子Agent，判定游戏胜负。 |
| **配置子 Agent (Setup Agent)** | **规则计算者**。负责板子解析、角色随机选择、特殊状态（如酒鬼）预埋。 |
| **夜间子 Agent (Night Agent)** | **逻辑处理者**。负责技能结算、信息生成（真/假信息）、状态变更（中毒/醉酒）。 |
| **复盘子 Agent (Summary Agent)** | **内容生成者**。负责基于日志生成游戏故事线复盘。 |

---

## 3. 功能需求详情

### 3.1 房间与大厅阶段 (Lobby Phase)
*由主 Agent 协助状态管理*

1.  **创建房间（房主）**：
    *   某个玩家在手机网页端创建房间，生成4位或6位数字房间号。
    *   无需登录，基于设备ID或临时Session标识。
2.  **加入房间（玩家）**：
    *   玩家输入房间号进入。（房主自动进入 ta 创建的房间）
    *   **座位绑定**：系统展示一个圆桌视图（UI模拟线下座位），房主可以增加或减少座位，圆桌大小会随着座位数变化，玩家点击对应位置号码“坐下”。位置号码和顺序至关重要，影响技能判定（如“你的邻居”）。
3.  **配置板子**：
    *   房主选择好剧本（如“灾祸滋生”、“暗流涌动”等）。
    *   玩家端在房主确定好剧本后自动调用配置子 Agent 根据玩家人数进行角色分配计算，并展示该剧本（通过获取提前上传到服务端的图片）和开始游戏按钮。
    *   **角色分发触发**：全员就座后，玩家点击开始游戏按钮，自动下发角色给所有玩家。系统立即锁定房间，禁止后续人员加入。

### 3.2 游戏初始化 (Setup Phase)
*核心逻辑由 配置子 Agent 执行*

1.  **角色池构建**：
    *   根据玩家人数和剧本规则，生成本局出现的角色列表（几镇民、几外来、几爪牙、几恶魔）。
    *   **酒鬼逻辑**：若存在“酒鬼”牌，Agent 需随机抽取一个本该存在的“镇民”角色替换为“酒鬼”实体，但向该玩家分发原来的“镇民”虚拟身份（系统后台标记其为：实际-酒鬼 / 感知-士兵）。
    *   Agent 需计算是否通过“**男爵**”技能修改了角色配比。
2.  **身份推送**：
    *   主 Agent 将分配好的角色私聊推送到各个玩家端。
    *   玩家端显示卡牌详情（名称、技能描述、阵营）。
    *   爪牙和恶魔的界面上，会有专门区域显示：“你的队友是：[座位号] [昵称]”以及“恶魔是：[座位号] [昵称]”。

### 3.3 夜晚阶段 (Night Phase)
*流程由 主 Agent 推进，逻辑由 夜间子 Agent 计算*

1.  **入夜播报**：主 Agent 通知玩家端播放语音和文字“天黑请闭眼”，全员手机端界面 UI 变为黑暗状态
2.  **唤醒流程（主 Agent 核心职能）（唤醒时不会播放语音防止暴露身份）**：
    *   **队列管理**：严格根据剧本定义的唤醒顺序（如：恶魔/爪牙 -> 占卜师...），依次唤醒角色。
        *   其中爪牙和恶魔通常为同一唤醒环节，并且首夜会通知爪牙和恶魔“请互相确认身份”，后续会通过 UI 提示邪恶队友是几号。
    *   **唤醒操作**：
        *   当前行动玩家的手机出现提示，允许操作。
        *   其他玩家手机保持 UI 黑暗状态。
3.  **技能结算（夜间子 Agent 核心职能）（每唤醒一个玩家就会执行）**：
    *   **输入**：玩家的选择（如查验了谁、毒了谁）。
        *   所有玩家选择前都要有一个确认机制，防止误操作。
    *   **处理**：
        *   判断发起者状态（是否中毒/醉酒）。
        *   判断目标状态（是否有保护/反弹）。
    *   **输出**：生成反馈信息。
        *   若中毒：Agent 需“编造”一条符合逻辑的假信息。
        *   若正常：返回真实信息。
    *   **信息发放**：结算结果由主 Agent 实时推送到玩家端。

### 3.4 白天阶段 (Day Phase)
*由 主 Agent 维持秩序*

1.  **天亮结算**：
    *   玩家端显示并播放“天亮了”语音。
    *   音频和 UI 公布昨夜死亡的玩家是几号。
    *   更新玩家存活状态（UI变灰、标记死亡）。
2.  **自由讨论**：
    *   主 Agent 开启倒计时（时长可配置）。
    *   倒计时结束，进入提名环节。
3.  **提名与处决 (Nomination & Execution)**：
    *   **发起提名**：存活玩家在玩家端可点击按钮选择玩家，发起对某人的提名，提名阶段有一个相对较短的倒计时（比如 10s）一旦有人发起，提名通道暂时关闭，进入该组提名流程。若无玩家提名则直接进入黑夜。
    *   **辩护流程**：玩家端展示“XX 提名了 YY”
        *   提名者先开始计时发言，阐述提名玩家的原因（玩家可以点击提前结束发言）。
        *   被提名者随后进行辩护（同样计时，可提前结束发言）。
    *   **投票系统**：
        *   提名和被提名玩家先后发言计时结束后，所有玩家在玩家端根据弹出的 UI 进行“同意/弃票”选择。
        *   **死人票管理**：系统自动检测已死亡玩家是否还有“死人票（Ghost Vote）”。死人票只能使用一次，若已用过，则禁止后续投票。存活玩家投票次数无限制。
        *   **无确认机制**：玩家点击投票后即直接计入票数，每个玩家有 1 - 3s 的投票时间，期间内未投票视为弃票。
    *   流程循环：
        *   一组提名流程结束后记录被提名玩家及其票数，将票数最高的玩家标记为待处决，进入新的重置之后的提名阶段倒计时，允许未发起过提名的玩家再次发起提名，直到没有玩家继续提名倒计时结束或当前已无玩家能继续发起提名（死人无法发起提名，但可以被提名）。（一个白天一名玩家只能提名一次和被提名一次）
    *   **处决结算**：
        *   主 Agent 统计票数。
        *   若票数大于等于场上存活玩家数量且为最高，即视为投票有效。
        *   处决最后有效的待处决玩家。
        *   更新被处决玩家状态为“死亡”（保留死人票）。
4.  **循环检查**：根据规则调用 agent 检查是否满足游戏结束条件。若未结束，进入下一轮夜晚。

### 3.5 游戏结束与复盘 (Game End)
*由 复盘子 Agent 执行*

1.  **胜负判定**：主 Agent 检测恶魔死亡或存活人数比例，宣布游戏结束及获胜方。
    * 每当有人死亡或入夜前，检查：恶魔是否死亡？存活人数是否只剩2人（恶魔胜利）？
2.  **智能复盘**：
    *   调用 **复盘子 Agent**。
    *   读取全剧日志（Log）。
    *   生成“故事线”：例如“第一晚，占卜师查验了A（其实是爪牙），但因为中了毒，得到了好人信息...”（或例如：第二晚，僧侣保护了A，恶魔刀了A，导致空刀）
    *   生成MVP/背锅位评价（趣味性功能）。
    *   将复盘报告推送到所有玩家手机。

---

## 4. 系统架构与技术要求

### 4.1 架构设计
*   **后端 (Server)**:
    *   **API Gateway**: 处理WebSocket长连接（实时性要求高）。（需处理移动端切屏可能导致的断连，比如一切换回来就重连之类的）
    *   **Agent Orchestrator**: 负责调度不同的Agent。
    *   **State Manager**: 内存数据库（如Redis），存储房间状态、玩家位置、技能CD、死人票状态。
*   **前端 (Client)**:
    *   **竖屏Web**: 玩家端使用，无需下载App。

### 4.2 Agent 交互逻辑
*   **Prompt Engineering**: 需要为每个子Agent设计详细的System Prompt，包含具体的游戏规则书（Rulebook）。（例如：你是一个严格的逻辑裁判。如果玩家处于'中毒'或'醉酒'状态，你必须忽略其真实的查验结果，编造一个虚假但可信的信息。如果玩家正常，返回真实结果。）
*   **Context Management**: 夜间Agent需要知道前几晚的所有动作，以判断复杂的逻辑链（如：A被B毒了，B被C换了，C其实是酒鬼）。

### 4.3 数据持久化
*   游戏过程中数据实时保存，防止断网导致对局丢失。
*   游戏结束后归档日志，用于生成复盘。

### 4.4 其他必须完整实现的后端技术功能
下列所有功能必须完整实现，不能只写to do，也不能有任何报错，必须完整可运行

* 设计 Orchestrator + Specialists 的分层多 Agent 架构，主 Agent 以 FSM 驱动游戏生命周期，将复杂流程拆解为可组合的子 Agent 与工具调用，对关键等待点引入超时与默认策略，将 LLM 调用旁路异步化，结果以事件回写，保证游戏阶段的可持续推进
* 通过事件溯源架构设计存储层，将提名、投票和处决等游戏操作序列化为不可变事件流，通过 Event Replay + 快照机制实现服务端状态重建与全局回放，配合 last_seq 增量补发机制，支撑断线重连后的状态恢复
* 开发基于 WebSocket 的实时通信层，利用 Actor 模型将每个房间作为独立的 Goroutine 运行，以 Channel 串行化处理玩家操作，结合 idempotency_key 做幂等去重，确保重复提交不破坏状态，解决了用户操作竞态问题，保证房间内顺序一致性
* 基于 MCP 协议标准化工具接入规范，将私信/请求确认/开关投票/推进阶段/写入事件等操作标准化为可校验的 JSON Schema 调用，长耗时任务通过 RabbitMQ 异步执行，统一治理超时重试、并发限制与审计记录，保证 Agent 行为可控可追溯
* 通过可见性投影实现严格的领域层信息隔离，服务端按玩家身份对事件与状态做权限裁剪，覆盖群聊、私聊、发放角色、夜晚真假信息等敏感数据，确保玩家端仅接收其应知信息
* 基于向量数据库搭建 RAG 系统，实现了对游戏规则书及角色技能的语义检索，结合对局短期记忆与阶段摘要进行检索增强，通过动态上下文注入减少了 LLM 在处理长文本规则时的幻觉问题